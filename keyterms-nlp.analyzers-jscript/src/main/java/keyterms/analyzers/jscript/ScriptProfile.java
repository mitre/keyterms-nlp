/*
 * NOTICE
 * This software was produced for the U.S. Government and is subject to the
 * Rights in Data-General Clause 5.227-14 (May 2014).
 * Copyright 2018 The MITRE Corporation. All rights reserved.
 *
 * “Approved for Public Release; Distribution Unlimited” Case  18-2165
 *
 * This project contains content developed by The MITRE Corporation.
 * If this code is used in a deployment or embedded within another project,
 * it is requested that you send an email to opensource@mitre.org
 * in order to let us know where this software is being used.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package keyterms.analyzers.jscript;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Predicate;

import keyterms.nlp.iso.Script;

/**
 * Script profile information generated by a script profiler.
 */
public class ScriptProfile {
    /**
     * The natural order for profile entries.
     */
    private static final Comparator<Entry> ENTRY_SORTER =
            Comparator.nullsLast(
                    Comparator.comparing(Entry::getCodePoints).reversed()
                            .thenComparing(Comparator.comparing(Entry::getKnownCodePointPercentage).reversed())
                            .thenComparing(Entry::getFirstIndex)
                            .thenComparing(Comparator.comparing(Entry::getRunCount).reversed())
                            .thenComparing(Comparator.comparing(Entry::getMeanRunSize).reversed()));

    /**
     * The allowable percentage difference between the top and next primary script to allow suppressing the primary
     * script choice.
     */
    private static final double SUPPRESS_THRESHOLD = 0.25;

    /**
     * The total number of code points in the analyzed text.
     */
    private final int codePoints;

    /**
     * The per script profile entries.
     */
    private List<Entry> entries;

    /**
     * Constructor.
     *
     * @param codePoints The total number of code points in the analyzed text.
     * @param profile The working information from the profile analyzer.
     */
    ScriptProfile(int codePoints, Map<Script, ScriptProfiler.WorkingEntry> profile) {
        super();
        this.codePoints = codePoints;
        Entry common = null;
        Entry unknown = null;
        entries = new ArrayList<>();
        for (Map.Entry<Script, ScriptProfiler.WorkingEntry> profileEntry : profile.entrySet()) {
            Script script = profileEntry.getKey();
            ScriptProfiler.WorkingEntry workingEntry = profileEntry.getValue();
            Entry entry = new Entry(script, workingEntry);
            entries.add(entry);
            if (Script.COMMON.equals(script)) {
                common = entry;
            }
            if (Script.UNKNOWN.equals(script)) {
                unknown = entry;
            }
        }
        entries.sort(ENTRY_SORTER);
        // Common and Unknown script entries always go last regardless of the prominence
        if (common != null) {
            entries.remove(common);
            entries.add(common);
        }
        if (unknown != null) {
            entries.remove(unknown);
            entries.add(unknown);
        }
        entries = Collections.unmodifiableList(entries);
    }

    /**
     * Get the total number of code points in the analyzed text.
     *
     * @return The total number of code points in the analyzed text.
     */
    public int getCodePointCount() {
        return codePoints;
    }

    /**
     * Get the total number of code points, in a script other than "COMMON" or "UNKNOWN", in the analyzed text.
     *
     * @return The total number of specified code points in the analyzed text.
     */
    public int getKnownCodePointCount() {
        return codePoints - (int)entries.stream()
                .filter((e) -> ((e.getScript().equals(Script.COMMON)) || (e.getScript().equals(Script.UNKNOWN))))
                .count();
    }

    /**
     * Determine if the text contains latin script characters other than those that are explicitly ignored.
     *
     * @return A flag indicating whether the text contains latin script characters.
     */
    public boolean containsLatin() {
        return contains(Script.LATN);
    }

    /**
     * Determine if the text contains non-latin script characters.
     *
     * @return A flag indicating whether the text contains non-latin script characters.
     */
    public boolean containsNonLatin() {
        return contains((s) -> ((s != Script.LATN) && (s != Script.ZYYY)));
    }

    /**
     * Determine if the text contains CJK script characters.
     *
     * @return A flag indicating whether the text contains CJK script characters.
     */
    public boolean containsCJK() {
        return contains(Script.CJK_SCRIPTS::contains);
    }

    /**
     * Determine if the text contains any characters in the specified script.
     *
     * @param scriptCode The script of interest.
     *
     * @return A flag indicating whether the text contains any characters in the specified script.
     */
    public boolean contains(Script scriptCode) {
        return contains((s) -> s.equals(scriptCode));
    }

    /**
     * Determine if the text contains any characters matching the specified script filter.
     *
     * @param filter The filter which selects scripts of interest.
     *
     * @return A flag indicating whether the text contains any characters matching the specified script filter.
     */
    public boolean contains(Predicate<Script> filter) {
        return entries.stream()
                .map(Entry::getScript)
                .anyMatch(filter);
    }

    /**
     * Get the most likely script for the profiled text.
     *
     * @return The most likely script for the profiled text.
     */
    public Script getScript() {
        return getScript(false);
    }

    /**
     * Get the most likely script for the profiled text.
     *
     * @param preferNonLatin A flag indicating whether to return a non-latin script.
     *
     * @return The most likely script for the profiled text.
     */
    public Script getScript(boolean preferNonLatin) {
        return getScript(preferNonLatin, false);
    }

    /**
     * Get the most likely script for the profiled text.
     *
     * @param preferNonLatin A flag indicating whether to return a non-latin script.
     * @param suppressLatin A flag indicating whether to always prefer a non-latin script.
     *
     * @return The most likely script for the profiled text.
     */
    public Script getScript(boolean preferNonLatin, boolean suppressLatin) {
        Script script = entries.get(0).getScript();
        if ((script == Script.LATN) && ((preferNonLatin) || (suppressLatin))) {
            double percentLatin = entries.get(0).getCodePointPercentage();
            Entry nextEntry = entries.get(1);
            Script nextScript = nextEntry.getScript();
            if ((!Script.COMMON.equals(nextScript)) && (!Script.UNKNOWN.equals(nextScript))) {
                if (suppressLatin) {
                    script = nextScript;
                } else {
                    double percentNext = nextEntry.getCodePointPercentage();
                    if ((percentLatin - percentNext) <= SUPPRESS_THRESHOLD) {
                        script = nextScript;
                    }
                }
            }
        }
        return script;
    }

    /**
     * Get the per script profile entries.
     *
     * @return The per script profile entries.
     */
    public List<Entry> getEntries() {
        return entries;
    }

    /**
     * Get the entry for the specified script.
     *
     * @param script The script of interest.
     *
     * @return The entry for the specified script.
     */
    public Entry getEntry(Script script) {
        return entries.stream()
                .filter((entry) -> Objects.equals(script, entry.script))
                .findFirst()
                .orElse(null);
    }

    /**
     * Profile information for a specific script.
     */
    public class Entry {
        /**
         * The script.
         */
        private final Script script;

        /**
         * The character index of the first code point from the script in the analyzed text.
         */
        private final int firstIndex;

        /**
         * The number of code points from the script in the analyzed text.
         */
        private final int codePoints;

        /**
         * The number of code point runs for the script in the analyzed text.
         */
        private final int runCount;

        /**
         * The size of the smallest code point run in the script.
         */
        private final int minimumRun;

        /**
         * The mean size of the code point runs in the script.
         */
        private final double meanRun;

        /**
         * The size of the largest code point run in the script.
         */
        private final int maximumRun;

        /**
         * Constructor.
         *
         * @param script The script.
         * @param workingEntry The working entry for the script.
         */
        Entry(Script script, ScriptProfiler.WorkingEntry workingEntry) {
            super();
            this.script = script;
            firstIndex = (workingEntry.firstIndex != null) ? workingEntry.firstIndex : -1;
            codePoints = workingEntry.codePoints;
            runCount = (int)workingEntry.runStats.getSize();
            if (runCount > 0) {
                minimumRun = workingEntry.runStats.getMinimum().intValue();
                meanRun = workingEntry.runStats.getMean();
                maximumRun = workingEntry.runStats.getMaximum().intValue();
            } else {
                minimumRun = 0;
                meanRun = 0;
                maximumRun = 0;
            }
        }

        /**
         * Get the script.
         *
         * @return The script.
         */
        public Script getScript() {
            return script;
        }

        /**
         * Get the character index of the first code point from the script in the analyzed text.
         *
         * @return The character index of the first code point from the script in the analyzed text.
         */
        public int getFirstIndex() {
            return firstIndex;
        }

        /**
         * Get the number of code points from the script in the analyzed text.
         *
         * @return The number of code points from the script in the analyzed text.
         */
        public int getCodePoints() {
            return codePoints;
        }

        /**
         * Get the number of code point runs for the script in the analyzed text.
         *
         * <p> A code point run is a contiguous group of characters in the same script. </p>
         *
         * @return The number of code point runs for the script in the analyzed text.
         */
        public int getRunCount() {
            return runCount;
        }

        /**
         * Get the size of the smallest code point run in the script.
         *
         * @return The size of the smallest code point run in the script.
         */
        public int getMinimumRunSize() {
            return minimumRun;
        }

        /**
         * Get the mean size of the code point runs in the script.
         *
         * @return The mean size of the code point runs in the script.
         */
        public double getMeanRunSize() {
            return meanRun;
        }

        /**
         * Get the size of the largest code point run in the script.
         *
         * @return The size of the smallest code point run in the script.
         */
        public int getMaximumRunSize() {
            return maximumRun;
        }

        /**
         * Get the percentage of code points from the script in the analyzed text.
         *
         * <p> The resultant value will be between {@code 0.0} and {@code 1.0} (inclusive). </p>
         *
         * @return The percentage of code points from the script in the analyzed text.
         */
        public double getCodePointPercentage() {
            double percent = 0;
            int profileCodePoints = ScriptProfile.this.codePoints;
            if (profileCodePoints > 0) {
                percent = (((double)codePoints) / ((double)profileCodePoints));
            }
            return percent;
        }

        /**
         * Get the percentage of classifiable code points from the script in the analyzed text.
         *
         * <p> This will be the number of code points within the script divided by the total code points in the
         * analyzed text that were not unknown or indeterminate. </p>
         *
         * @return The percentage of classifiable code points from the script in the analyzed text.
         */
        public double getKnownCodePointPercentage() {
            double percent = 0;
            int profileCodePoints = ScriptProfile.this.getKnownCodePointCount();
            if (profileCodePoints > 0) {
                percent = (((double)codePoints) / ((double)profileCodePoints));
            }
            return percent;
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
            return script.getCode() + "(" + codePoints + ")";
        }
    }
}